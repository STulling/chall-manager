syntax = "proto3";

package api.v1.launch;

import "google/api/annotations.proto";
import "google/api/field_behavior.proto";
import "google/protobuf/duration.proto";
import "google/protobuf/empty.proto";
import "google/protobuf/timestamp.proto";
import "protoc-gen-openapiv2/options/annotations.proto";

option go_package = "github.com/ctfer-io/chall-manager/gen/protos/go/api/v1/launch;launch";

option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_swagger) = {
    info: {
        title: "Chall-Manager gRPC-gateway generated REST API";
        version: "v1.0.0";
        description: "The gRPC-gateway generated REST API OpenAPIv2 swagger.";
        contact: {
            name: "CTFer.io";
            url: "https://ctfer.io";
            email: "ctfer-io@protonmail.com";
        };
        license: {
            name: "Apache-License 2.0";
            url: "https://github.com/ctfer-io/chall-manager/blob/main/LICENSE";
        };
    };
    schemes: HTTP;
    consumes: "application/json";
    produces: "application/json";
};

// Launcher is in charge of handling scenario launch requests.
// It waits for a CTF backend to send a request for a scenario on the fly, then deploys
// it and returns the connection information.
service Launcher {
    // CreateLaunch receives the scenario LaunchRequest and returns a LaunchResponse.
    rpc CreateLaunch(LaunchRequest) returns (LaunchResponse) {
        option(google.api.http) = {
            post: "/api/v1/launch"
            body: "*"
        };
    }

    // RetrieveLaunch retrieves the stack information about an instance.
    // Usefull for re-syncing applications once disconnected due to a network or
    // service failure.
    rpc RetrieveLaunch(RetrieveLaunchRequest) returns (LaunchResponse) {
        option(google.api.http) = {
            get: "/api/v1/launch/{challenge_id}/{source_id}"
        };
    }

    // QueryLaunches retrieves the stack information about all instances.
    // Usefull for syncing an admin dashboard to the chall-manager instances.
    rpc QueryLaunches(google.protobuf.Empty) returns (stream QueryLaunchResponse) {
        option(google.api.http) = {
            get: "/api/v1/launch"
        };
    }

    // UpdateLaunch udpates an existing challenge scenario on demand.
    rpc UpdateLaunch(UpdateLaunchRequest) returns (LaunchResponse) {
        option(google.api.http) = {
            patch: "/api/v1/launch"
        };
    }
    
    // DeleteLaunch destroy the resources of a challenge scenario.
    rpc DeleteLaunch(LaunchRequest) returns (google.protobuf.Empty) {
        option(google.api.http) = {
            delete: "/api/v1/launch"
        };
    }
}

// LaunchRequest is a scenario launch request.
// Please refer to the webdoc to better understand the chall-manager design.
message LaunchRequest {
    // The challenge ID to launch. Given for traceability through requests and
    // used for generating the "identity" value (see SDK design).
    string challenge_id = 1 [(grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {example: "1"}, (google.api.field_behavior) = REQUIRED];
    // The source ID i.e. the identifier of the user/team/anything that issued
    // the request. You must make sure to map it to only one kind, e.g. not sending
    // teams and/or users ID at same time, else there will be collisions thus cause
    // the scenario launch to never complete.
    string source_id = 2 [(grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {example: "1"}, (google.api.field_behavior) = REQUIRED];
    // The scenario is a base64-encoded zip archive containing the entrypoint to run.
    //
    // Notice this would be executed with the same rights that the chall-manager thus
    // enable RCE: make sure to never expose it. We recommend using a service-mesh with
    // mTLS enabled between the chall-manager replicas and the CTF backends ones.
    //
    // For most of the cases, you don't have to deal with it on your own, but for
    // developers and integrators, refer to the chall-manager code internals if curious
    // on how this payload is handled or how the SDK is binded.
    string scenario = 3 [(grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {example: "\"base64(zip(.))\""}, (google.api.field_behavior) = REQUIRED];

    oneof dates {
        // The timeout after which the janitor will have permission to delete the
        // resources.
        google.protobuf.Duration timeout = 4;
        // The date after which the janitor will have permission to delete the
        // resources.
        google.protobuf.Timestamp until = 5;
    };
}

// LaunchResponse is a scenario launch response.
// Please refer to the webdoc to better understand the chall-manager design.
message LaunchResponse {
    // The connection information to the launched scenario.
    //
    // Most of the time, this is a simple example on how to connect hence could be
    // used as is by the player. Please make sure to avoid implicit informations
    // (ports, headers, protocol, etc.) to enable players focus on the actual value
    // of your efforts: the challenge.
    string connection_info = 1 [(grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {example: "\"curl -v https://identity.ctfer.io/index.html\""}, (google.api.field_behavior) = REQUIRED];
    // Timestamp the challenge is expected to run until.
    // Due to latencies it is not guaranteed, but could happen at any time.
    google.protobuf.Timestamp until = 2;
    // The flag is a non-mantdatory response specific to the Challenge Scenario on
    // Demand, and is the payload to validate this challenge.
    // It enables variability thus shareflag (does not natively block from sharing
    // writeups or anything similar).
    optional string flag = 3 [(grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {example: "\"CTFER{ÏnƒRåŠ7rÜ©†ûrè ã§ ©Ödè}\""}, (google.api.field_behavior) = OPTIONAL];
}

// QueryLaunchResponse is a reponse that index a LaunchResponse given the challenge
// and source identifiers to enable listing all running Challenge Scenario on Demand.
message QueryLaunchResponse {
    // The challenge ID to launch. Given for traceability through requests and
    // used for generating the "identity" value (see SDK design).
    string challenge_id = 1 [(grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {example: "1"}, (google.api.field_behavior) = REQUIRED];
    // The source ID i.e. the identifier of the user/team/anything that issued
    // the request. You must make sure to map it to only one kind, e.g. not sending
    // teams and/or users ID at same time, else there will be collisions thus cause
    // the scenario launch to never complete.
    string source_id = 2 [(grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {example: "1"}, (google.api.field_behavior) = REQUIRED];
    // The scenario launch response.
    LaunchResponse launch_response = 3 [(google.api.field_behavior) = REQUIRED];
}

// RetrieveLaunchRequest is a scenario launch information request.
message RetrieveLaunchRequest {
    // The challenge ID to launch. Given for traceability through requests and
    // used for generating the "identity" value (see SDK design).
    string challenge_id = 1 [(grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {example: "1"}, (google.api.field_behavior) = REQUIRED];
    // The source ID i.e. the identifier of the user/team/anything that issued
    // the request. You must make sure to map it to only one kind, e.g. not sending
    // teams and/or users ID at same time, else there will be collisions thus cause
    // the scenario launch to never complete.
    string source_id = 2 [(grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {example: "1"}, (google.api.field_behavior) = REQUIRED];
}

message UpdateLaunchRequest {
    // The challenge ID to launch. Given for traceability through requests and
    // used for generating the "identity" value (see SDK design).
    string challenge_id = 1 [(grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {example: "1"}, (google.api.field_behavior) = REQUIRED];
    // The source ID i.e. the identifier of the user/team/anything that issued
    // the request. You must make sure to map it to only one kind, e.g. not sending
    // teams and/or users ID at same time, else there will be collisions thus cause
    // the scenario launch to never complete.
    string source_id = 2 [(grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {example: "1"}, (google.api.field_behavior) = REQUIRED];

    oneof dates {
        // The timeout after which the janitor will have permission to delete the
        // resources.
        google.protobuf.Duration timeout = 4;
        // The date after which the janitor will have permission to delete the
        // resources.
        google.protobuf.Timestamp until = 5;
    };
}
